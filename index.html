<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Lotus Trance – Digital Ocean Sun</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      color: #fff;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
                   Roboto, sans-serif;
    }
    canvas {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      background: radial-gradient(circle at center, #050505 0%, #000 55%, #000 100%);
    }
    .ui-main {
      position: fixed;
      left: 7vw;
      bottom: 8vh;
      z-index: 2;
      pointer-events: none;
      mix-blend-mode: screen;
      text-transform: uppercase;
      letter-spacing: 0.25em;
    }
    .ui-main h1 {
      font-size: clamp(1.6rem, 3vw, 3.2rem);
      font-weight: 600;
      margin-bottom: 0.7rem;
      text-shadow: 0 0 16px rgba(255, 255, 255, 0.8);
    }
    .ui-main .divider {
      width: 110px;
      height: 1px;
      background: linear-gradient(
        90deg,
        rgba(255, 255, 255, 0) 0%,
        rgba(255, 255, 255, 0.9) 50%,
        rgba(255, 255, 255, 0) 100%
      );
      margin: 0.6rem 0 0.7rem -4px;
    }
    .ui-main p {
      font-size: 0.7rem;
      opacity: 0.8;
    }
    .ui-main .tagline {
      font-size: 0.65rem;
      margin-top: 0.35rem;
      opacity: 0.7;
    }
    .corner-label {
      position: fixed;
      right: 4vw;
      top: 4vh;
      z-index: 2;
      font-size: 0.6rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      opacity: 0.55;
      pointer-events: none;
      mix-blend-mode: screen;
    }
    .corner-label span {
      display: block;
      text-align: right;
    }
    .corner-label span:first-child {
      margin-bottom: 0.2rem;
    }
  </style>
</head>
<body>
  <canvas id="scene"></canvas>

  <div class="ui-main">
    <h1>LOTUS TRANCE</h1>
    <div class="divider"></div>
    <p>Digital ocean • Mandala sun • Quantum geometry</p>
    <p class="tagline">Blue sound waves • Red sunset reflection</p>
  </div>

  <div class="corner-label">
    <span>SHADER SYSTEM v3.0</span>
    <span>WEBGL / OCEAN–SUN ENGINE</span>
  </div>

  <script>
    const canvas = document.getElementById("scene");
    const gl = canvas.getContext("webgl", { antialias: true, premultipliedAlpha: false });

    if (!gl) {
      alert("WebGL не поддерживается этим браузером.");
    }

    function resize() {
      const w = window.innerWidth;
      const h = window.innerHeight;
      canvas.width = w;
      canvas.height = h;
      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    }
    window.addEventListener("resize", resize);
    resize();

    const vsSource = `
      attribute vec2 a_position;
      varying vec2 v_uv;
      void main() {
        v_uv = a_position * 0.5 + 0.5;
        gl_Position = vec4(a_position, 0.0, 1.0);
      }
    `;

    const fsSource = `
      precision highp float;

      uniform vec2 u_resolution;
      uniform float u_time;
      varying vec2 v_uv;

      // тонкая линия вокруг кривой (distance ~ 0)
      float lineAround(float d, float w) {
        return 1.0 - smoothstep(w, w * 4.0, abs(d));
      }

      // кольцо-звуковая волна (многополосное, вокруг центра p=0)
      float waveRing(vec2 p, float radius, float freq, float amp, float speed) {
        float ang = atan(p.y, p.x);
        float rad = length(p);

        float wave =
          sin(ang * freq + u_time * speed) +
          0.5 * sin(ang * (freq * 1.9) - u_time * (speed * 1.3));

        float target = radius + wave * amp;
        float d = rad - target;
        return lineAround(d, 0.006);
      }

      void main() {
        vec2 res = u_resolution;
        // uv в 0..1, (0,0) снизу слева
        vec2 uv = gl_FragCoord.xy / res;

        float horizon = 0.45;

        // базовый фон: небо / океан
        vec3 col;
        if (uv.y > horizon) {
          float t = (uv.y - horizon) / (1.0 - horizon);
          t = clamp(t, 0.0, 1.0);
          vec3 skyTop = vec3(0.01, 0.015, 0.08);
          vec3 skyMid = vec3(0.01, 0.012, 0.055);
          vec3 skyBot = vec3(0.0, 0.0, 0.02);
          vec3 sky = mix(skyBot, mix(skyBot, skyTop, 0.6), t);
          col = sky;
        } else {
          float t = uv.y / horizon;
          t = clamp(t, 0.0, 1.0);
          vec3 waterBot = vec3(0.002, 0.015, 0.05);
          vec3 waterMid = vec3(0.01, 0.04, 0.11);
          vec3 waterTop = vec3(0.02, 0.08, 0.22);
          vec3 water = mix(waterBot, mix(waterMid, waterTop, t), t);
          col = water;
        }

        // координаты для солнца/мандалы: центр в (0.5, horizon)
        float horizonY = horizon;
        vec2 sunCenterPx = vec2(0.5 * res.x, horizonY * res.y);
        vec2 p = (gl_FragCoord.xy - sunCenterPx) / res.y; // центрированное, с коррекцией аспекта

        // мандала-солнце
        float mandala = 0.0;
        mandala += waveRing(p, 0.18, 12.0, 0.02, 1.4);
        mandala += waveRing(p, 0.25, 16.0, 0.024, 1.7);
        mandala += waveRing(p, 0.33, 22.0, 0.028, 2.0);

        // ядро солнца
        float dSun = length(p);
        float coreBase = 0.12;
        float corePulse = coreBase + 0.01 * sin(u_time * 2.5);
        float core = 1.0 - smoothstep(corePulse - 0.005, corePulse + 0.005, dSun);

        // тёплая палитра
        vec3 sunColorCore = vec3(1.2, 0.55, 0.30);
        vec3 sunColorRing = vec3(1.1, 0.35, 0.20);

        // добавляем мандалу и ядро к цвету
        col += sunColorRing * mandala * 1.3;
        col += sunColorCore * core * 1.7;

        // ореол по вертикали вдоль горизонта
        float haloH = coreBase * 1.8;
        float haloT = smoothstep(0.0, haloH, abs(uv.y - horizonY));
        float halo = 1.0 - haloT;
        vec3 haloColor = vec3(1.0, 0.35, 0.20);
        col += haloColor * halo * 0.18;

        // ОКЕАН: линии волн (толстые, полупрозрачные)
        if (uv.y < horizon) {
          float oceanDepth = horizon;
          float wavesFine = 0.0;
          float wavesAccent = 0.0;

          // тонкие многочисленные волны (задний план)
          for (int i = 0; i < 24; i++) {
            float fi = float(i);
            float tLayer = fi / 23.0;
            float yBase = horizon * (0.08 + tLayer * 0.9);

            float amp = 0.01 + tLayer * 0.02;
            float speed = 0.4 + tLayer * 0.9;
            float k1 = 15.0 + tLayer * 10.0;
            float k2 = 5.0 + tLayer * 6.0;

            float phase = u_time * speed + uv.x * k1 + fi * 0.5;
            float phase2 = u_time * (speed * 0.7) - uv.x * k2;

            float offset =
              sin(phase) * amp * (0.4 + 0.6 * sin(u_time * 0.7 + fi)) +
              sin(phase2) * amp * 0.5;

            float yTarget = yBase + offset;
            float line = lineAround(uv.y - yTarget, 0.0015);

            float alpha = 0.4 * (1.0 - tLayer);
            wavesFine += line * alpha;
          }

          // акцентные волны спереди — толще
          for (int i = 0; i < 5; i++) {
            float fi = float(i);
            float tLayer = (fi + 1.0) / 7.0;
            float yBase = horizon * (0.5 + tLayer * 0.45);

            float amp = 0.02 + tLayer * 0.03;
            float speed = 0.8 + tLayer * 1.4;
            float k1 = 20.0 + tLayer * 10.0;
            float k2 = 10.0 + tLayer * 8.0;

            float phase = u_time * speed + uv.x * k1 - fi;
            float phase2 = u_time * (speed * 0.6) - uv.x * k2;

            float offset =
              sin(phase) * amp +
              sin(phase2) * amp * 0.5;

            float yTarget = yBase + offset;
            float line = lineAround(uv.y - yTarget, 0.0025);

            float alpha = 0.9 * (1.0 - tLayer);
            wavesAccent += line * alpha;
          }

          vec3 waveColorBase = vec3(0.30, 0.60, 1.00);
          vec3 waveColorAccent = vec3(0.55, 0.80, 1.10);

          col += waveColorBase * wavesFine * 0.7;
          col += waveColorAccent * wavesAccent * 0.85;
        }

        // ОТРАЖЕНИЕ СОЛНЦА НА ВОДЕ
        if (uv.y < horizon) {
          float tRef = (horizon - uv.y) / horizon;
          tRef = clamp(tRef, 0.0, 1.0);

          float width = 0.12;
          float dx = (uv.x - 0.5) / width;
          float spot = exp(-dx * dx * 2.0);

          float ripple = 0.5 + 0.5 * sin(u_time * 2.2 + uv.y * 80.0);
          float reflection = spot * (1.0 - tRef) * ripple;

          vec3 reflColor = vec3(1.0, 0.35, 0.2);
          col += reflColor * reflection * 1.4;
        }

        // лёгкая виньетка
        vec2 centered = (gl_FragCoord.xy - 0.5 * res) / res.y;
        float r = length(centered);
        float vignette = smoothstep(1.4, 0.4, r);
        col *= vignette;

        // filmic
        col = 1.0 - exp(-col);
        col = clamp(col, 0.0, 1.0);

        gl_FragColor = vec4(col, 1.0);
      }
    `;

    function createShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    function createProgram(gl, vsSource, fsSource) {
      const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
      const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
      const program = gl.createProgram();
      gl.attachShader(program, vs);
      gl.attachShader(program, fs);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
        return null;
      }
      return program;
    }

    const program = createProgram(gl, vsSource, fsSource);
    gl.useProgram(program);

    const positionLocation = gl.getAttribLocation(program, "a_position");
    const timeLocation = gl.getUniformLocation(program, "u_time");
    const resolutionLocation = gl.getUniformLocation(program, "u_resolution");

    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    const quad = new Float32Array([
      -1, -1,
       1, -1,
      -1,  1,
      -1,  1,
       1, -1,
       1,  1,
    ]);
    gl.bufferData(gl.ARRAY_BUFFER, quad, gl.STATIC_DRAW);

    gl.enableVertexAttribArray(positionLocation);
    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

    let startTime = performance.now();

    function render(now) {
      const t = (now - startTime) * 0.001;

      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
      gl.clearColor(0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT);

      gl.useProgram(program);
      gl.uniform1f(timeLocation, t);
      gl.uniform2f(resolutionLocation, gl.drawingBufferWidth, gl.drawingBufferHeight);

      gl.drawArrays(gl.TRIANGLES, 0, 6);

      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);
  </script>
</body>
</html>
