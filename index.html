<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Lotus Trance – Quantum Mandala</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      color: #fff;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
                   Roboto, sans-serif;
    }
    canvas {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      background: radial-gradient(circle at center, #050505 0%, #000 55%, #000 100%);
    }
    .ui-main {
      position: fixed;
      left: 7vw;
      bottom: 8vh;
      z-index: 2;
      pointer-events: none;
      mix-blend-mode: screen;
      text-transform: uppercase;
      letter-spacing: 0.25em;
    }
    .ui-main h1 {
      font-size: clamp(1.6rem, 3vw, 3.2rem);
      font-weight: 600;
      margin-bottom: 0.7rem;
      text-shadow: 0 0 16px rgba(255, 255, 255, 0.8);
    }
    .ui-main .divider {
      width: 110px;
      height: 1px;
      background: linear-gradient(
        90deg,
        rgba(255, 255, 255, 0) 0%,
        rgba(255, 255, 255, 0.9) 50%,
        rgba(255, 255, 255, 0) 100%
      );
      margin: 0.6rem 0 0.7rem -4px;
    }
    .ui-main p {
      font-size: 0.7rem;
      opacity: 0.8;
    }
    .ui-main .tagline {
      font-size: 0.65rem;
      margin-top: 0.35rem;
      opacity: 0.7;
    }
    .corner-label {
      position: fixed;
      right: 4vw;
      top: 4vh;
      z-index: 2;
      font-size: 0.6rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      opacity: 0.55;
      pointer-events: none;
      mix-blend-mode: screen;
    }
    .corner-label span {
      display: block;
      text-align: right;
    }
    .corner-label span:first-child {
      margin-bottom: 0.2rem;
    }
  </style>
</head>
<body>
  <canvas id="scene"></canvas>

  <div class="ui-main">
    <h1>LOTUS TRANCE</h1>
    <div class="divider"></div>
    <p>8-petal white lotus • Sonic mandala • Quantum geometry</p>
    <p class="tagline">GPU shader • Click to glitch • Ritual visuals</p>
  </div>

  <div class="corner-label">
    <span>SHADER SYSTEM v2.0</span>
    <span>WEBGL / LOTUS–MANDALA ENGINE</span>
  </div>

  <script>
    const canvas = document.getElementById("scene");
    const gl = canvas.getContext("webgl", { antialias: true, premultipliedAlpha: false });

    if (!gl) {
      alert("WebGL не поддерживается этим браузером.");
    }

    function resize() {
      const w = window.innerWidth;
      const h = window.innerHeight;
      canvas.width = w;
      canvas.height = h;
      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    }
    window.addEventListener("resize", resize);
    resize();

    let mouse = { x: 0.5, y: 0.5 }; // нормализованные координаты 0..1
    window.addEventListener("pointermove", (e) => {
      mouse.x = e.clientX / window.innerWidth;
      mouse.y = 1.0 - e.clientY / window.innerHeight;
    });

    let glitchStrength = 0.0;
    window.addEventListener("click", () => {
      glitchStrength = 1.0; // глич-пик по клику
    });

    const vsSource = `
      attribute vec2 a_position;
      varying vec2 v_uv;
      void main() {
        v_uv = a_position * 0.5 + 0.5;
        gl_Position = vec4(a_position, 0.0, 1.0);
      }
    `;

    const fsSource = `
      precision highp float;

      uniform vec2 u_resolution;
      uniform float u_time;
      uniform vec2 u_mouse;
      uniform float u_glitch;

      varying vec2 v_uv;

      float hash(vec2 p) {
        return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
      }

      // тонкая линия вокруг кривой (distance ~ 0)
      float lineAround(float d, float w) {
        return 1.0 - smoothstep(w, w * 4.0, abs(d));
      }

      // 8-лепестковый лотос в полярных координатах
      float lotusLayer(vec2 p, float baseR, float scale, float tShift) {
        p *= scale;
        float ang = atan(p.y, p.x);
        float rad = length(p);

        float petals = 8.0;
        float k = cos(petals * ang * 0.5);
        float k2 = cos(petals * ang + tShift);

        float r =
          baseR
          + 0.18 * pow(abs(k), 1.6)
          + 0.05 * k2 * cos(u_time * 0.7 + tShift);

        float vib =
          0.02 * sin(ang * 16.0 + u_time * 2.3) +
          0.01 * sin(ang * 9.0 - u_time * 3.7);

        r += vib;

        float d = rad - r;
        float w = 0.006;
        float line = lineAround(d, w);

        float inner = 1.0 - smoothstep(0.0, baseR * 2.0, rad);
        return line * (0.3 + 0.7 * inner);
      }

      // кольцо-звуковая волна (многополосная мандала)
      float waveRing(vec2 p, float radius, float freq, float amp, float speed) {
        float ang = atan(p.y, p.x);
        float rad = length(p);

        float wave =
          sin(ang * freq + u_time * speed) +
          0.5 * sin(ang * (freq * 1.9) - u_time * (speed * 1.3));

        float target = radius + wave * amp;
        float d = rad - target;
        return lineAround(d, 0.005);
      }

      // квадратная линия (мандала из вписанных квадратов)
      float boxLine(vec2 p, float size, float thickness) {
        vec2 d = abs(p) - vec2(size);
        float dist = max(d.x, d.y);
        return 1.0 - smoothstep(thickness, thickness * 4.0, abs(dist));
      }

      void main() {
        vec2 res = u_resolution;
        vec2 uv = (gl_FragCoord.xy - 0.5 * res) / res.y; // центр, фикс аспекта

        // параллакс от мыши
        vec2 m = (u_mouse - 0.5) * 2.0;
        float rotAngle = m.x * 0.6 + sin(u_time * 0.1) * 0.05;
        float c = cos(rotAngle);
        float s = sin(rotAngle);
        mat2 rot = mat2(c, -s, s, c);
        uv = rot * uv;

        // лёгкое радиальное искривление от мыши
        float rLen = length(uv);
        float warp = 1.0 + m.y * 0.25 * smoothstep(0.0, 0.7, rLen);
        uv *= warp;

        // glitch-сдвиги (строго шейдер, без тяжёлых циклов)
        float g = u_glitch;
        if (g > 0.0) {
          float bandNoise = hash(vec2(floor(uv.y * 60.0), floor(u_time * 40.0)));
          float xShift = (bandNoise - 0.5) * 0.15 * g;
          uv.x += xShift;

          float jitter = (hash(vec2(floor(uv * 80.0))) - 0.5) * 0.06 * g;
          uv += jitter;
        }

        // ЛОТОС
        float lotus =
          lotusLayer(uv, 0.25, 1.1, 0.0) +
          lotusLayer(uv, 0.32, 1.0, 1.57) * 0.8 +
          lotusLayer(uv, 0.40, 0.9, 3.14) * 0.6;

        // ЗВУКОВАЯ МАНДАЛА
        float mandala =
          waveRing(uv, 0.38, 14.0, 0.03, 1.8) +
          waveRing(uv, 0.48, 18.0, 0.035, 2.1) +
          waveRing(uv, 0.60, 24.0, 0.04, 2.5) * 0.9;

        // КВАДРАТНАЯ СИММЕТРИЯ (двойной квадрат в лотосе)
        vec2 p1 = uv * 1.3;
        float sq1 = boxLine(p1, 0.27, 0.005);
        mat2 r45 = mat2(0.7071, -0.7071, 0.7071, 0.7071);
        vec2 p2 = r45 * p1;
        float sq2 = boxLine(p2, 0.27, 0.005);
        float squares = sq1 + sq2 * 0.9;

        // ЯДРО
        float coreR = length(uv);
        float corePulse =
          0.3 +
          0.7 * (0.5 + 0.5 * sin(u_time * 4.7 + coreR * 20.0));
        float core =
          (1.0 - smoothstep(0.0, 0.10, coreR)) *
          (1.0 - smoothstep(0.02, 0.08, coreR)) *
          corePulse;

        // ПСЕВДО-ЧАСТИЦЫ / ЗВЁЗДНАЯ ПЫЛЬ
        vec2 grid = floor(uv * res.y * 0.7);
        float grain = pow(hash(grid), 22.0);
        float particles = grain * smoothstep(0.1, 0.8, coreR);

        // ОБЩИЙ ГЛОУ
        float glow =
          lotus * 1.2 +
          mandala * 0.9 +
          squares * 0.7 +
          core * 1.5 +
          particles * 0.6;

        // виньетирование (чтобы края уходили в чёрный)
        float vignette = smoothstep(1.25, 0.2, length(uv));
        glow *= vignette;

        // лёгкая квантовая "спектральность" по краю, но основной цвет — белый
        vec3 col = vec3(glow);
        vec3 spectral = vec3(0.6, 0.8, 1.4) * (mandala * 0.18);
        col += spectral;

        // усиление линий лотоса белым
        col += vec3(1.0) * lotus * 0.4;

        // глич: небольшое выгорание при пике
        if (g > 0.0) {
          col *= 1.0 + g * 0.5;
        }

        // filmic
        col = 1.0 - exp(-col);
        col = clamp(col, 0.0, 1.0);

        gl_FragColor = vec4(col, 1.0);
      }
    `;

    function createShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    function createProgram(gl, vsSource, fsSource) {
      const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
      const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
      const program = gl.createProgram();
      gl.attachShader(program, vs);
      gl.attachShader(program, fs);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
        return null;
      }
      return program;
    }

    const program = createProgram(gl, vsSource, fsSource);
    gl.useProgram(program);

    const positionLocation = gl.getAttribLocation(program, "a_position");
    const timeLocation = gl.getUniformLocation(program, "u_time");
    const resolutionLocation = gl.getUniformLocation(program, "u_resolution");
    const mouseLocation = gl.getUniformLocation(program, "u_mouse");
    const glitchLocation = gl.getUniformLocation(program, "u_glitch");

    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    const quad = new Float32Array([
      -1, -1,
       1, -1,
      -1,  1,
      -1,  1,
       1, -1,
       1,  1,
    ]);
    gl.bufferData(gl.ARRAY_BUFFER, quad, gl.STATIC_DRAW);

    gl.enableVertexAttribArray(positionLocation);
    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

    let startTime = performance.now();
    let lastTime = startTime;

    function render(now) {
      const t = (now - startTime) * 0.001;
      const dt = (now - lastTime) * 0.001;
      lastTime = now;

      // затухание глича
      if (glitchStrength > 0) {
        glitchStrength -= dt * 2.2; // ~0.35 c
        if (glitchStrength < 0) glitchStrength = 0;
      }

      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
      gl.clearColor(0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT);

      gl.useProgram(program);
      gl.uniform1f(timeLocation, t);
      gl.uniform2f(resolutionLocation, gl.drawingBufferWidth, gl.drawingBufferHeight);
      gl.uniform2f(mouseLocation, mouse.x, mouse.y);
      gl.uniform1f(glitchLocation, glitchStrength);

      gl.drawArrays(gl.TRIANGLES, 0, 6);

      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);
  </script>
</body>
</html>
