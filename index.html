<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Lotus Trance Label</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      width: 100%;
      height: 100%;
      background: #000;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        Roboto, sans-serif;
      color: #fff;
    }

    canvas {
      position: fixed;
      inset: 0;
      display: block;
      background: radial-gradient(circle at center, #050505 0%, #000 60%, #000 100%);
    }

    .ui {
      position: fixed;
      left: 7vw;
      bottom: 8vh;
      z-index: 10;
      text-transform: uppercase;
      letter-spacing: 0.25em;
      pointer-events: none;
      mix-blend-mode: screen;
    }

    .ui h1 {
      font-size: clamp(1.4rem, 2.2vw, 2.8rem);
      font-weight: 600;
      margin-bottom: 0.7rem;
      text-shadow: 0 0 12px rgba(255, 255, 255, 0.6);
    }

    .ui p {
      font-size: 0.7rem;
      opacity: 0.8;
    }

    .ui .tagline {
      font-size: 0.65rem;
      margin-top: 0.4rem;
      opacity: 0.7;
    }

    .ui .divider {
      width: 80px;
      height: 1px;
      background: linear-gradient(
        90deg,
        rgba(255, 255, 255, 0) 0%,
        rgba(255, 255, 255, 0.7) 50%,
        rgba(255, 255, 255, 0) 100%
      );
      margin: 0.6rem 0 0.6rem -2px;
    }

    .corner-label {
      position: fixed;
      right: 4vw;
      top: 4vh;
      z-index: 10;
      font-size: 0.6rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      opacity: 0.5;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <canvas id="scene"></canvas>

  <div class="ui">
    <h1>Lotus Trance</h1>
    <div class="divider"></div>
    <p>Fractal sound design • High-frequency art</p>
    <p class="tagline">Eight-petal geometry • Sonic mandala • Quantum particles</p>
  </div>

  <div class="corner-label">▲ Hyper-resonant visual for a trance label</div>

  <script>
    const canvas = document.getElementById("scene");
    const ctx = canvas.getContext("2d");

    let width = window.innerWidth;
    let height = window.innerHeight;
    let dpr = window.devicePixelRatio || 1;
    let centerX = width / 2;
    let centerY = height / 2;
    let particles = [];

    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      dpr = window.devicePixelRatio || 1;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      centerX = width / 2;
      centerY = height / 2;
    }

    window.addEventListener("resize", resize);
    resize();

    // --- helpers ---
    function rand(min, max) {
      return min + Math.random() * (max - min);
    }

    function createParticles(count) {
      particles = [];
      const maxR = Math.min(width, height) * 0.6;
      for (let i = 0; i < count; i++) {
        particles.push({
          baseRadius: rand(maxR * 0.15, maxR * 0.55),
          angle: rand(0, Math.PI * 2),
          speed: rand(-0.0008, 0.0008),
          size: rand(0.7, 2.1),
          noiseAmp: rand(4, 16),
          noiseFreq: rand(1.5, 4.0),
          alphaPhase: rand(0, Math.PI * 2),
        });
      }
    }

    createParticles(420);

    function drawLotus(time) {
      const r = Math.min(width, height) * 0.18;
      const petals = 8;
      const wobble = 0.08;
      const lines = 4;

      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.rotate(time * 0.05);

      for (let j = 0; j < lines; j++) {
        const radiusOffset = j * 6;
        ctx.beginPath();
        for (let i = 0; i <= 720; i++) {
          const t = (i / 720) * Math.PI * 2;
          const base = r + radiusOffset;
          const petal = Math.sin((t * petals) / 2);
          const vibrate =
            Math.sin(t * 20 + time * 3 + j * 0.9) * base * wobble * 0.06;
          const rr = base * (0.7 + 0.3 * Math.abs(petal)) + vibrate;
          const x = rr * Math.cos(t);
          const y = rr * Math.sin(t);
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        const alpha = 0.24 + j * 0.08;
        ctx.strokeStyle = `rgba(255,255,255,${alpha})`;
        ctx.lineWidth = 0.8;
        ctx.shadowBlur = 12;
        ctx.shadowColor = "rgba(255,255,255,0.85)";
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawMandalaSquares(time) {
      const baseR = Math.min(width, height) * 0.20;

      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.rotate(time * -0.03);

      ctx.globalCompositeOperation = "lighter";

      const layers = 6;
      for (let i = 0; i < layers; i++) {
        const t = i / (layers - 1 || 1);
        const r = baseR * (0.6 + t * 1.2);
        const rot =
          time * 0.25 * (i % 2 === 0 ? 1 : -1) + t * Math.PI * 0.25;

        ctx.save();
        ctx.rotate(rot);

        const shake = Math.sin(time * 6 + i) * 0.02;
        const size = r * (1 + shake);
        const half = size / 2;

        ctx.beginPath();
        ctx.moveTo(-half, -half);
        ctx.lineTo(half, -half);
        ctx.lineTo(half, half);
        ctx.lineTo(-half, half);
        ctx.closePath();

        const alpha = 0.08 + 0.12 * (1 - t);
        ctx.strokeStyle = `rgba(255,255,255,${alpha})`;
        ctx.lineWidth = 0.7;
        ctx.shadowBlur = 15;
        ctx.shadowColor = "rgba(255,255,255,0.7)";
        ctx.stroke();

        ctx.restore();
      }

      ctx.restore();
    }

    function drawSonicMandala(time) {
      const baseR = Math.min(width, height) * 0.23;
      const rings = 3;

      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.globalCompositeOperation = "lighter";

      for (let j = 0; j < rings; j++) {
        const tRing = j / (rings - 1 || 1);
        const r = baseR * (1 + tRing * 0.65);
        const amp = 10 + 26 * (1 - tRing);
        const freq = 10 + 6 * tRing;

        ctx.beginPath();
        for (let i = 0; i <= 1200; i++) {
          const t = (i / 1200) * Math.PI * 2;
          const wave =
            Math.sin(t * freq + time * (0.9 + j * 0.3)) * amp *
            (0.4 + 0.6 * Math.sin(t * 0.5 + j));
          const rr = r + wave;
          const x = rr * Math.cos(t);
          const y = rr * Math.sin(t);
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        const alpha = 0.13 + 0.12 * (1 - tRing);
        ctx.strokeStyle = `rgba(255,255,255,${alpha})`;
        ctx.lineWidth = 0.9;
        ctx.shadowBlur = 18;
        ctx.shadowColor = "rgba(255,255,255,0.9)";
        ctx.stroke();
      }

      ctx.restore();
    }

    function updateAndDrawParticles(time) {
      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.globalCompositeOperation = "lighter";

      for (let i = 0; i < particles.length; i++) {
        const p = particles[i];
        p.angle += p.speed;

        const noise =
          Math.sin(p.angle * p.noiseFreq + time * 2.0) * p.noiseAmp;
        const r = p.baseRadius + noise;
        const x = r * Math.cos(p.angle);
        const y = r * Math.sin(p.angle);

        const alpha =
          0.12 +
          0.18 *
            (0.5 + 0.5 * Math.sin(time * 2.5 + p.alphaPhase + p.baseRadius * 0.01));

        ctx.beginPath();
        ctx.arc(x, y, p.size, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255,255,255,${alpha})`;
        ctx.shadowBlur = 12;
        ctx.shadowColor = "rgba(255,255,255,0.8)";
        ctx.fill();
      }

      ctx.restore();
    }

    function renderFrame(timestamp) {
      const time = timestamp * 0.001;

      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.clearRect(0, 0, width, height);

      // лёгкий «шлейф» вместо полного стирания — даёт ощущение вибрации
      ctx.globalCompositeOperation = "source-over";
      ctx.fillStyle = "rgba(0,0,0,0.2)";
      ctx.fillRect(0, 0, width, height);

      drawLotus(time);
      drawMandalaSquares(time);
      drawSonicMandala(time);
      updateAndDrawParticles(time);

      requestAnimationFrame(renderFrame);
    }

    requestAnimationFrame(renderFrame);
  </script>
</body>
</html>
