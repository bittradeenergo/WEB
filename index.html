<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Digital Ocean Mandala Sunset</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000010;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
                   Roboto, sans-serif;
      color: #fff;
    }

    canvas {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      background: radial-gradient(circle at top, #060818 0%, #020313 40%, #02020a 100%);
    }

    .ui-main {
      position: fixed;
      left: 7vw;
      top: 7vh;
      z-index: 2;
      pointer-events: none;
      mix-blend-mode: screen;
      text-transform: uppercase;
      letter-spacing: 0.3em;
    }

    .ui-main h1 {
      font-size: clamp(1.2rem, 2vw, 2.4rem);
      font-weight: 600;
      margin-bottom: 0.5rem;
      text-shadow: 0 0 14px rgba(255, 255, 255, 0.75);
    }

    .ui-main .divider {
      width: 100px;
      height: 1px;
      background: linear-gradient(
        90deg,
        rgba(255, 255, 255, 0) 0%,
        rgba(255, 255, 255, 0.9) 50%,
        rgba(255, 255, 255, 0) 100%
      );
      margin: 0.5rem 0 0.6rem -3px;
    }

    .ui-main p {
      font-size: 0.65rem;
      opacity: 0.8;
    }

    .ui-main .tagline {
      font-size: 0.6rem;
      margin-top: 0.3rem;
      opacity: 0.7;
    }

    .corner-label {
      position: fixed;
      right: 4vw;
      bottom: 5vh;
      z-index: 2;
      font-size: 0.55rem;
      letter-spacing: 0.25em;
      text-transform: uppercase;
      opacity: 0.55;
      pointer-events: none;
      mix-blend-mode: screen;
      text-align: right;
    }
  </style>
</head>
<body>
  <canvas id="scene"></canvas>

  <div class="ui-main">
    <h1>DIGITAL OCEAN</h1>
    <div class="divider"></div>
    <p>Blue sound waves • Mandala sun</p>
    <p class="tagline">Trance label visual • Lightweight canvas</p>
  </div>

  <div class="corner-label">
    QUANTUM SOUND SCAPE
  </div>

  <script>
    const canvas = document.getElementById("scene");
    const ctx = canvas.getContext("2d");

    let width = window.innerWidth;
    let height = window.innerHeight;

    // занижаем внутреннее разрешение ради производительности
    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      const scale = 0.75;
      canvas.width = width * scale;
      canvas.height = height * scale;
      ctx.setTransform(scale, 0, 0, scale, 0, 0);
    }

    window.addEventListener("resize", resize);
    resize();

    let lastTime = performance.now();

    function drawBackground() {
      const g = ctx.createLinearGradient(0, 0, 0, height);
      g.addColorStop(0.0, "#050719");
      g.addColorStop(0.4, "#020416");
      g.addColorStop(0.75, "#02051c");
      g.addColorStop(1.0, "#010310");
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, width, height);
    }

    // мандала-солнце из волнующихся колец
    function drawMandalaSun(time) {
      const horizonY = height * 0.45;
      const centerX = width * 0.5;
      const baseRadius = Math.min(width, height) * 0.11;

      // общий ореол
      const glowGrad = ctx.createRadialGradient(
        centerX, horizonY, 0,
        centerX, horizonY, baseRadius * 2.2
      );
      glowGrad.addColorStop(0.0, "rgba(255, 160, 110, 0.7)");
      glowGrad.addColorStop(0.4, "rgba(255, 90, 70, 0.45)");
      glowGrad.addColorStop(0.9, "rgba(255, 0, 0, 0)");
      ctx.fillStyle = glowGrad;
      ctx.beginPath();
      ctx.arc(centerX, horizonY, baseRadius * 2.2, 0, Math.PI * 2);
      ctx.fill();

      ctx.save();
      ctx.translate(centerX, horizonY);

      const rings = 4;
      const steps = 360;

      for (let j = 0; j < rings; j++) {
        const t = j / (rings - 1 || 1);
        const r = baseRadius * (0.7 + t * 0.9);
        const amp = 4 + t * 10;
        const freq = 10 + t * 6;
        const speed = 1.3 + t * 0.7;

        ctx.beginPath();
        for (let i = 0; i <= steps; i++) {
          const a = (i / steps) * Math.PI * 2;

          const wave =
            Math.sin(a * freq + time * speed) * amp *
            (0.4 + 0.6 * Math.sin(a * 0.7 + time * 0.5 + j));

          const radius = r + wave;
          const x = radius * Math.cos(a);
          const y = radius * Math.sin(a);

          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }

        const alpha = 0.4 + 0.2 * (1.0 - t);
        const red = 255;
        const green = 90 + (1 - t) * 80;
        const blue = 60 + (1 - t) * 40;
        ctx.strokeStyle = `rgba(${red}, ${green}, ${blue}, ${alpha})`;
        ctx.lineWidth = 1.5 - t * 0.5;
        ctx.shadowBlur = 10;
        ctx.shadowColor = "rgba(255, 150, 110, 0.9)";
        ctx.stroke();
      }

      // внутреннее пульсирующее ядро
      const corePulse = 1 + 0.04 * Math.sin(time * 3.2);
      const coreRadius = baseRadius * 0.55 * corePulse;

      ctx.beginPath();
      ctx.arc(0, 0, coreRadius, 0, Math.PI * 2);
      ctx.strokeStyle = "rgba(255, 230, 200, 0.95)";
      ctx.lineWidth = 1.3;
      ctx.shadowBlur = 12;
      ctx.shadowColor = "rgba(255, 210, 180, 0.9)";
      ctx.stroke();

      ctx.restore();

      // линейный ореол вдоль горизонта
      const haloGrad = ctx.createLinearGradient(
        0, horizonY - baseRadius * 0.3,
        0, horizonY + baseRadius * 0.8
      );
      haloGrad.addColorStop(0.0, "rgba(255, 120, 80, 0.4)");
      haloGrad.addColorStop(0.5, "rgba(255, 60, 40, 0.12)");
      haloGrad.addColorStop(1.0, "rgba(255, 0, 0, 0.0)");
      ctx.fillStyle = haloGrad;
      ctx.fillRect(0, horizonY - baseRadius * 0.6, width, baseRadius * 1.6);
    }

    function drawSunReflection(time) {
      const horizonY = height * 0.45;
      const centerX = width * 0.5;
      const maxDepth = height * 0.5;
      const baseWidth = Math.min(width, height) * 0.1;

      ctx.save();
      ctx.translate(centerX, horizonY);

      const bands = 40;
      for (let i = 0; i < bands; i++) {
        const t = i / bands;
        const y = t * maxDepth;

        const wavePhase = time * 1.2 + y * 0.04;
        const wobble = Math.sin(wavePhase) * (4 + t * 14);
        const lineWidthHalf = baseWidth * (0.6 + t * 2.8);

        const alpha = 0.55 * (1.0 - t) *
          (0.4 + 0.6 * Math.sin(time * 0.7 + t * 3.0) * 0.5);
        if (alpha < 0.02) continue;

        const color = `rgba(255, ${80 + (1 - t) * 120}, ${60 + (1 - t) * 40}, ${alpha})`;
        ctx.strokeStyle = color;
        ctx.lineWidth = 1.4;
        ctx.beginPath();
        ctx.moveTo(-lineWidthHalf - wobble, y);
        ctx.lineTo(lineWidthHalf + wobble, y);
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawWaves(time) {
      const oceanTop = height * 0.45;
      const oceanHeight = height - oceanTop;

      // градиент океана
      const g = ctx.createLinearGradient(0, oceanTop, 0, height);
      g.addColorStop(0.0, "#041b3a");
      g.addColorStop(0.4, "#03142e");
      g.addColorStop(1.0, "#010918");
      ctx.fillStyle = g;
      ctx.fillRect(0, oceanTop, width, height - oceanTop);

      ctx.save();
      ctx.beginPath();
      ctx.rect(0, oceanTop, width, height - oceanTop);
      ctx.clip();

      // основной набор волн — толще и полупрозрачные
      const waveCount = 28;
      const stepX = 24;
      for (let i = 0; i < waveCount; i++) {
        const t = i / (waveCount - 1 || 1);
        const yBase = oceanTop + t * oceanHeight * 0.98;

        const amp = 6 + t * 14;
        const speed = 0.4 + t * 0.9;
        const k1 = 0.004 + t * 0.004;
        const k2 = 0.009 + t * 0.006;

        let r = 120 + t * 80;
        let gC = 180 + t * 60;
        let bC = 255;

        const brightnessBoost = 0.2 + 0.8 * (1.0 - t);
        r = r * brightnessBoost;
        gC = gC * brightnessBoost;
        bC = bC * (0.8 + 0.2 * brightnessBoost);

        // делаем волны более прозрачными
        const alpha = 0.10 + 0.22 * (1.0 - t);

        ctx.beginPath();
        for (let x = 0; x <= width + stepX; x += stepX) {
          const phase = time * speed + x * k1 + i * 0.5;
          const phase2 = time * (speed * 0.7) - x * k2;
          const offset =
            Math.sin(phase) * amp * (0.4 + 0.6 * Math.sin(time * 0.7 + i)) +
            Math.sin(phase2) * amp * 0.35;

          const y = yBase + offset;
          if (x === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }

        ctx.strokeStyle = `rgba(${r.toFixed(0)}, ${gC.toFixed(0)}, ${bC.toFixed(0)}, ${alpha.toFixed(3)})`;
        ctx.lineWidth = 1.5;  // толще
        ctx.shadowBlur = 0;
        ctx.stroke();
      }

      // акцентные волны ближе к зрителю — ещё толще, но тоже полупрозрачные
      const accentCount = 5;
      for (let i = 0; i < accentCount; i++) {
        const t = (i + 1) / (accentCount + 2);
        const yBase = oceanTop + (0.4 + t * 0.55) * oceanHeight;

        const amp = 10 + t * 20;
        const speed = 0.8 + t * 1.4;
        const k1 = 0.005 + t * 0.006;
        const k2 = 0.008 + t * 0.008;

        ctx.beginPath();
        for (let x = 0; x <= width + stepX; x += stepX) {
          const phase = time * speed + x * k1 - i;
          const phase2 = time * (speed * 0.6) - x * k2;
          const offset =
            Math.sin(phase) * amp +
            Math.sin(phase2) * amp * 0.5;

          const y = yBase + offset;
          if (x === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }

        ctx.strokeStyle = "rgba(140, 210, 255, 0.55)";
        ctx.lineWidth = 2.1; // толще акцент
        ctx.shadowBlur = 10;
        ctx.shadowColor = "rgba(100, 190, 255, 0.8)";
        ctx.stroke();
      }

      ctx.restore();
    }

    function loop(now) {
      const dt = (now - lastTime) * 0.001;
      lastTime = now;
      const time = now * 0.001;

      drawBackground();
      drawMandalaSun(time);
      drawSunReflection(time);
      drawWaves(time);

      requestAnimationFrame(loop);
    }

    requestAnimationFrame(loop);
  </script>
</body>
</html>
