<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Lotus Trance – Fractal Mandala</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      width: 100%;
      height: 100%;
      background: #000;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        Roboto, sans-serif;
      color: #fff;
    }

    canvas {
      position: fixed;
      inset: 0;
      display: block;
      background:
        radial-gradient(circle at center, #050505 0%, #000 60%, #000 100%);
    }

    .ui-main {
      position: fixed;
      left: 7vw;
      bottom: 8vh;
      z-index: 10;
      pointer-events: none;
      mix-blend-mode: screen;
      text-transform: uppercase;
      letter-spacing: 0.25em;
    }

    .ui-main h1 {
      font-size: clamp(1.6rem, 3vw, 3.2rem);
      font-weight: 600;
      margin-bottom: 0.7rem;
      text-shadow: 0 0 16px rgba(255, 255, 255, 0.8);
    }

    .ui-main .divider {
      width: 110px;
      height: 1px;
      background: linear-gradient(
        90deg,
        rgba(255, 255, 255, 0) 0%,
        rgba(255, 255, 255, 0.9) 50%,
        rgba(255, 255, 255, 0) 100%
      );
      margin: 0.6rem 0 0.7rem -4px;
    }

    .ui-main p {
      font-size: 0.7rem;
      opacity: 0.8;
    }

    .ui-main .tagline {
      font-size: 0.65rem;
      margin-top: 0.35rem;
      opacity: 0.7;
    }

    .corner-label {
      position: fixed;
      right: 4vw;
      top: 4vh;
      z-index: 10;
      font-size: 0.6rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      opacity: 0.55;
      pointer-events: none;
      mix-blend-mode: screen;
    }

    .corner-label span {
      display: block;
      text-align: right;
    }

    .corner-label span:first-child {
      margin-bottom: 0.2rem;
    }
  </style>
</head>
<body>
  <canvas id="scene"></canvas>

  <div class="ui-main">
    <h1>LOTUS TRANCE</h1>
    <div class="divider"></div>
    <p>Hyper–detailed lotus geometry • Sonic mandala engine</p>
    <p class="tagline">Fractal waveforms • Particle field • Ritual-grade visuals</p>
  </div>

  <div class="corner-label">
    <span>VISUAL SYSTEM v1.1</span>
    <span>CLICK TO GLITCH / OPTIMIZED</span>
  </div>

  <script>
    const canvas = document.getElementById("scene");
    const ctx = canvas.getContext("2d");

    let width = window.innerWidth;
    let height = window.innerHeight;
    let dpr = 1;
    let centerX = width / 2;
    let centerY = height / 2;

    let mouseX = 0;
    let mouseY = 0;
    let targetMouseX = 0;
    let targetMouseY = 0;

    // glitch
    let glitchTime = 0;
    const GLITCH_DURATION = 0.35; // секунды
    let glitchJitterX = 0;
    let glitchJitterY = 0;

    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      const baseDpr = window.devicePixelRatio || 1;
      // кап по DPI для производительности
      dpr = Math.min(baseDpr, 1.3);

      canvas.width = width * dpr;
      canvas.height = height * dpr;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      centerX = width / 2;
      centerY = height / 2;
    }

    window.addEventListener("resize", () => {
      resize();
      initParticles();
    });
    resize();

    window.addEventListener("pointermove", (e) => {
      const nx = (e.clientX / width - 0.5) * 2;
      const ny = (e.clientY / height - 0.5) * 2;
      targetMouseX = nx;
      targetMouseY = ny;
    });

    window.addEventListener("click", () => {
      glitchTime = GLITCH_DURATION;
    });

    function pseudoNoise(t) {
      return (
        Math.sin(t * 1.3) * 0.5 +
        Math.sin(t * 2.7 + 1.234) * 0.25 +
        Math.sin(t * 5.1 + 5.678) * 0.15
      );
    }

    // --- частицы ---
    class Particle {
      constructor(radiusMax) {
        this.reset(radiusMax);
      }

      reset(radiusMax) {
        this.layer = Math.random(); // 0..1
        this.baseRadius = (0.2 + Math.random() * 0.8) * radiusMax;
        this.angle = Math.random() * Math.PI * 2;
        this.speed =
          (Math.random() * 0.0012 + 0.0003) * (Math.random() < 0.5 ? -1 : 1);
        this.size = 0.7 + Math.random() * 1.4;
        this.noiseAmp = 6 + Math.random() * 24;
        this.noiseFreq = 1.3 + Math.random() * 3.2;
        this.flickerPhase = Math.random() * Math.PI * 2;
      }

      update(dt, time) {
        this.angle += this.speed * dt;
        const n = pseudoNoise(this.angle * this.noiseFreq + time * 1.3);
        const radius = this.baseRadius + n * this.noiseAmp;
        const parallax = 1 + this.layer * 0.25;

        const px = radius * Math.cos(this.angle) * parallax;
        const py = radius * Math.sin(this.angle) * parallax;

        const flicker =
          0.5 + 0.5 * Math.sin(time * 2.5 + this.flickerPhase);

        const alpha =
          0.06 + 0.18 * flicker * (0.35 + 0.65 * (1 - this.layer));

        return { x: px, y: py, alpha };
      }
    }

    const particles = [];
    function initParticles() {
      particles.length = 0;
      const maxR = Math.min(width, height) * 0.8;
      // уменьшили количество частиц
      const count = Math.floor(260 + Math.min(width, height) * 0.09);
      for (let i = 0; i < count; i++) {
        particles.push(new Particle(maxR));
      }
    }
    initParticles();

    // --- лотос ---
    function drawLotus(time) {
      const baseR = Math.min(width, height) * 0.18;
      const petals = 8;
      const layers = 5;

      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.translate(glitchJitterX * 0.5, glitchJitterY * 0.5);

      const mx = mouseX * 14;
      const my = mouseY * 14;
      ctx.translate(mx * 0.3, my * 0.3);

      ctx.globalCompositeOperation = "lighter";

      const steps = 520; // было 1200

      for (let j = 0; j < layers; j++) {
        const tLayer = j / (layers - 1 || 1);
        const rMult = 0.75 + tLayer * 0.9;
        const localR = baseR * rMult;
        const wobble = 0.1 + 0.16 * tLayer;

        ctx.beginPath();

        for (let i = 0; i <= steps; i++) {
          const t = (i / steps) * Math.PI * 2;

          const k = petals;
          const m = Math.sin((k * t) / 2);
          const m2 = Math.sin((k * t) / 2 + Math.PI / 8);
          let r =
            localR *
            (0.72 +
              0.23 * Math.abs(m) +
              0.13 * Math.abs(m2) * Math.sin(t * 0.5 + time * 0.4 + j));

          const vib =
            Math.sin(t * 18 + time * 4.5 + j * 0.8) * localR * wobble * 0.05 +
            Math.sin(t * 9.7 - time * 2.8) * localR * wobble * 0.03;
          r += vib;

          const x = r * Math.cos(t);
          const y = r * Math.sin(t);

          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }

        const alpha = 0.17 + 0.1 * (1 - tLayer);
        ctx.strokeStyle = `rgba(255,255,255,${alpha})`;
        ctx.lineWidth = 0.6 + tLayer * 0.25;
        ctx.shadowBlur = 14; // было 24
        ctx.shadowColor = "rgba(255,255,255,0.9)";
        ctx.stroke();
      }

      ctx.restore();
    }

    // --- квадратно-фрактальная мандала ---
    function drawMandalaSquares(time) {
      const baseR = Math.min(width, height) * 0.22;

      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.translate(glitchJitterX * 0.6, glitchJitterY * 0.6);
      ctx.globalCompositeOperation = "lighter";

      const mx = mouseX * 24;
      const my = mouseY * 24;
      ctx.translate(mx * 0.15, my * 0.15);

      const layers = 5; // было 7
      for (let i = 0; i < layers; i++) {
        const tLayer = i / (layers - 1 || 1);
        const r = baseR * (0.5 + tLayer * 1.4);

        const baseRot = time * 0.13 * (i % 2 === 0 ? 1 : -1);
        const squareRot =
          baseRot +
          tLayer * (Math.PI / 4) +
          Math.sin(time * 0.6 + i) * 0.025;

        ctx.save();
        ctx.rotate(squareRot);

        const sizeWave = 1 + 0.04 * Math.sin(time * 3 + i * 2);
        const size = r * sizeWave;
        const half = size / 2;

        ctx.beginPath();
        ctx.moveTo(-half, -half);
        ctx.lineTo(half, -half);
        ctx.lineTo(half, half);
        ctx.lineTo(-half, half);
        ctx.closePath();

        const alphaBase = 0.12 + 0.05 * (1 - tLayer);
        ctx.strokeStyle = `rgba(255,255,255,${alphaBase})`;
        ctx.lineWidth = 0.6;
        ctx.shadowBlur = 12; // меньше blur
        ctx.shadowColor = "rgba(255,255,255,0.7)";
        ctx.stroke();

        // внутренние деления (сильно сокращены)
        const subdiv = 6; // было 10
        const lowAlpha = alphaBase * 0.6;
        ctx.strokeStyle = `rgba(255,255,255,${lowAlpha})`;
        ctx.lineWidth = 0.35;

        for (let s = 1; s < subdiv; s++) {
          const k = s / subdiv;
          const offset = (k - 0.5) * size;

          ctx.beginPath();
          ctx.moveTo(offset, -half);
          ctx.lineTo(offset, half);
          ctx.moveTo(-half, offset);
          ctx.lineTo(half, offset);
          ctx.stroke();
        }

        ctx.restore();
      }

      ctx.restore();
    }

    // --- звуковая волна-мандала ---
    function drawSonicMandala(time) {
      const baseR = Math.min(width, height) * 0.26;

      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.translate(glitchJitterX * 0.7, glitchJitterY * 0.7);
      ctx.globalCompositeOperation = "lighter";

      const mx = mouseX * 30;
      const my = mouseY * 30;
      ctx.translate(mx * 0.07, my * 0.07);

      const rings = 3; // было 4
      const steps = 720; // было 2000

      for (let j = 0; j < rings; j++) {
        const tRing = j / (rings - 1 || 1);
        const r = baseR * (0.85 + tRing * 0.7);

        const amp = 12 + 26 * (1 - tRing);

        ctx.beginPath();
        for (let i = 0; i <= steps; i++) {
          const t = (i / steps) * Math.PI * 2;

          const baseFreq = 9 + j * 3;
          const mod =
            Math.sin(t * baseFreq + time * (1.4 + j * 0.45)) +
            0.5 * Math.sin(t * baseFreq * 1.8 - time * 1.9) +
            0.25 * Math.sin(t * baseFreq * 2.6 + time * 0.9);

          const envelope =
            0.55 + 0.45 * Math.sin(t * 2 + j * 1.1 + time * 0.3);

          const wave = mod * amp * envelope;
          const rr = r + wave;

          const x = rr * Math.cos(t);
          const y = rr * Math.sin(t);

          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }

        const alpha = 0.17 + 0.15 * (1 - tRing);
        ctx.strokeStyle = `rgba(255,255,255,${alpha})`;
        ctx.lineWidth = 1.0 - tRing * 0.35;
        ctx.shadowBlur = 16;
        ctx.shadowColor = "rgba(255,255,255,0.9)";
        ctx.stroke();
      }

      ctx.restore();
    }

    // --- ядро ---
    function drawCore(time) {
      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.translate(glitchJitterX, glitchJitterY);
      ctx.globalCompositeOperation = "lighter";

      const mx = mouseX * 20;
      const my = mouseY * 20;
      ctx.translate(mx * 0.18, my * 0.18);

      const baseR = Math.min(width, height) * 0.055;
      const pulse =
        1 + 0.1 * Math.sin(time * 5.2) + 0.05 * Math.sin(time * 9.7);
      const radius = baseR * pulse;

      const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, radius * 1.5);
      grad.addColorStop(0, "rgba(255,255,255,0.95)");
      grad.addColorStop(0.4, "rgba(255,255,255,0.55)");
      grad.addColorStop(1, "rgba(255,255,255,0)");
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(0, 0, radius * 1.5, 0, Math.PI * 2);
      ctx.fill();

      const rays = 40; // было 64
      ctx.lineWidth = 0.8;
      ctx.shadowBlur = 12;
      ctx.shadowColor = "rgba(255,255,255,0.85)";
      for (let i = 0; i < rays; i++) {
        const a = (i / rays) * Math.PI * 2;
        const mod =
          0.45 +
          0.55 *
            (0.5 +
              0.5 *
                Math.sin(a * 1.8 + time * 5.0 + Math.sin(a * 2.7)));
        const len = baseR * 2 * mod;
        const x = Math.cos(a) * len;
        const y = Math.sin(a) * len;
        const alpha = 0.08 + 0.17 * mod;
        ctx.strokeStyle = `rgba(255,255,255,${alpha})`;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(x, y);
        ctx.stroke();
      }

      ctx.beginPath();
      ctx.arc(0, 0, radius * 1.2, 0, Math.PI * 2);
      ctx.lineWidth = 0.7;
      ctx.strokeStyle = "rgba(255,255,255,0.7)";
      ctx.shadowBlur = 10;
      ctx.shadowColor = "rgba(255,255,255,0.8)";
      ctx.stroke();

      ctx.restore();
    }

    // --- halo ---
    function drawHalo() {
      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.translate(glitchJitterX * 0.3, glitchJitterY * 0.3);
      const maxR = Math.min(width, height) * 0.42;
      const grad = ctx.createRadialGradient(0, 0, maxR * 0.1, 0, 0, maxR);
      grad.addColorStop(0, "rgba(255,255,255,0)");
      grad.addColorStop(0.45, "rgba(255,255,255,0.16)");
      grad.addColorStop(0.9, "rgba(255,255,255,0)");
      ctx.globalCompositeOperation = "lighter";
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(0, 0, maxR, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    // --- частицы ---
    function drawParticles(time, dt) {
      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.translate(glitchJitterX * 0.4, glitchJitterY * 0.4);
      ctx.globalCompositeOperation = "lighter";

      const mx = mouseX * 40;
      const my = mouseY * 40;
      ctx.translate(mx * 0.22, my * 0.22);

      const maxR = Math.min(width, height) * 0.8;

      for (let i = 0; i < particles.length; i++) {
        const p = particles[i];
        const { x, y, alpha } = p.update(dt, time);

        const dist = Math.sqrt(x * x + y * y);
        if (dist > maxR * 1.1) {
          p.reset(maxR);
          continue;
        }

        const glow = 8 + (1 - p.layer) * 12;

        ctx.beginPath();
        ctx.arc(x, y, p.size, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255,255,255,${alpha})`;
        ctx.shadowBlur = glow;
        ctx.shadowColor = "rgba(255,255,255,0.9)";
        ctx.fill();
      }

      ctx.restore();
    }

    // --- glitch overlay (полосы/сдвиг) ---
    function drawGlitchOverlay(glitchPhase) {
      if (glitchPhase <= 0) return;

      const intensity = glitchPhase;

      ctx.save();
      ctx.globalCompositeOperation = "screen";

      const bands = 6;
      for (let i = 0; i < bands; i++) {
        if (Math.random() > intensity) continue;
        const bandHeight = (height / bands) * (0.3 + Math.random() * 0.4);
        const y = Math.random() * height;
        ctx.fillStyle = `rgba(255,255,255,${0.04 + 0.08 * intensity})`;
        ctx.fillRect(
          (Math.random() - 0.5) * 40,
          y,
          width * (0.9 + Math.random() * 0.3),
          bandHeight
        );
      }

      // вертикальные "разрывы"
      const cuts = 3;
      for (let i = 0; i < cuts; i++) {
        if (Math.random() > intensity * 0.8) continue;
        const cutWidth = (width / 12) * (0.4 + Math.random() * 0.8);
        const x = Math.random() * width;
        ctx.fillStyle = `rgba(255,255,255,${0.03 + 0.07 * intensity})`;
        ctx.fillRect(
          x,
          (Math.random() - 0.5) * 40,
          cutWidth,
          height * (0.9 + Math.random() * 0.2)
        );
      }

      ctx.restore();
    }

    let lastTimestamp = 0;

    function renderFrame(timestamp) {
      if (!lastTimestamp) lastTimestamp = timestamp;
      const dtMs = timestamp - lastTimestamp;
      lastTimestamp = timestamp;
      const dt = Math.min(dtMs, 50) / 1000; // в секундах
      const time = timestamp * 0.001;

      mouseX += (targetMouseX - mouseX) * 0.08;
      mouseY += (targetMouseY - mouseY) * 0.08;

      if (glitchTime > 0) glitchTime = Math.max(0, glitchTime - dt);
      const glitchPhase = glitchTime / GLITCH_DURATION;

      glitchJitterX =
        (Math.random() - 0.5) * 30 * glitchPhase;
      glitchJitterY =
        (Math.random() - 0.5) * 30 * glitchPhase;

      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      ctx.globalCompositeOperation = "source-over";
      ctx.fillStyle = "rgba(0, 0, 0, 0.24)";
      ctx.fillRect(0, 0, width, height);

      drawHalo();
      drawParticles(time, dt);
      drawSonicMandala(time);
      drawMandalaSquares(time);
      drawLotus(time);
      drawCore(time);
      drawGlitchOverlay(glitchPhase);

      requestAnimationFrame(renderFrame);
    }

    requestAnimationFrame(renderFrame);
  </script>
</body>
</html>
