<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AKULADHARA</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: #000;
    height: 100%;
    font-family: 'Helvetica Neue', sans-serif;
  }
  #canvas { display: block; }
  .overlay-text {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #ffd700;
    text-align: center;
    font-size: 3em;
    pointer-events: none;
    text-shadow: 0 0 15px #ffd700, 0 0 30px #fff;
  }
  #audioControl {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 10;
  }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div class="overlay-text">AKULADHARA</div>
<audio id="audioControl" controls src="your-track.mp3"></audio>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let w, h;
function resize() { w = canvas.width = window.innerWidth; h = canvas.height = window.innerHeight; }
window.addEventListener('resize', resize);
resize();
// Настройки мандалы
const petals = 8;
const fractalLevels = 3;
const baseRadius = 120;
const basePetalRadius = 30;
let rotationSpeed = 0;
let time = 0;
let mouseHover = false;
let mouseClick = false;
// Цветовая палитра
const colors = ['#0b1f5d', '#ffffff', '#d32f2f', '#ffd700'];
// Интерактивность мыши
canvas.addEventListener('mousemove', () => mouseHover = true);
canvas.addEventListener('mouseleave', () => mouseHover = false);
canvas.addEventListener('mousedown', () => mouseClick = true);
canvas.addEventListener('mouseup', () => mouseClick = false);
// Аудио и анализатор
const audio = document.getElementById('audioControl');
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const analyser = audioCtx.createAnalyser();
const source = audioCtx.createMediaElementSource(audio);
source.connect(analyser);
analyser.connect(audioCtx.destination);
analyser.fftSize = 1024;
const dataArray = new Uint8Array(analyser.frequencyBinCount);
// BPM и пульсация
let lastPeak = 0;
let bpmIntensity = 0;
// Функция рисования фрактального лепестка с золотой пылью и радиальной динамикой
function drawFractalLine(x, y, radius, level, hue, intensity, depth=0) {
    if(level === 0 || depth>5) return;
    const threads = 3 + Math.floor(Math.random()*3);
    for(let i=0; i<threads; i++){
        let angle = Math.random()*Math.PI*2 + Math.sin(time*0.01+i*0.5)*0.5;
        let r = radius * (0.4 + Math.random()*0.6);
        let dx = x + r * Math.cos(angle) + (Math.random()-0.5)*5*intensity;
        let dy = y + r * Math.sin(angle) + (Math.random()-0.5)*5*intensity;
        // Золотая пыль с радиальной динамикой и переливами
        for(let p=0; p<4; p++){
            let radiusOffset = (Math.random()*r*0.5 + r*0.2) * Math.sin(time*0.01 + p);
            let px = dx + radiusOffset * Math.cos(time*0.05 + p);
            let py = dy + radiusOffset * Math.sin(time*0.05 + p);
            let gradient = ctx.createRadialGradient(px, py, 0, px, py, 4);
            gradient.addColorStop(0, `hsla(${(hue+time*Math.random()*0.5)%360},100%,80%,1)`);
            gradient.addColorStop(1, 'rgba(255,215,0,0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(px, py, 1.5, 0, Math.PI*2);
            ctx.fill();
        }
        // Основная нить ветви
        let gradientMain = ctx.createRadialGradient(dx, dy, 0, dx, dy, 4);
        gradientMain.addColorStop(0, `hsla(${(hue+time*Math.random()*0.5)%360},100%,70%,1)`);
        gradientMain.addColorStop(1, 'rgba(255,215,0,0)');
        ctx.fillStyle = gradientMain;
        ctx.beginPath();
        ctx.arc(dx, dy, 2,0,Math.PI*2);
        ctx.fill();
        drawFractalLine(dx, dy, radius*0.5, level-1, hue+20, intensity, depth+1);
    }
}
// Центральный вихрь золотой пыли
function drawCentralVortex(intensity){
    let vortexParticles = 60;
    for(let i=0; i<vortexParticles; i++){
        let angle = (i/ vortexParticles)*Math.PI*2 + time*0.01;
        let radius = 10 + i*1.5 + Math.sin(time*0.02+i)*5;
        let zVib = Math.sin(time*0.03 + i)*2; // Z-вибрация
        let px = (radius + zVib) * Math.cos(angle);
        let py = (radius + zVib) * Math.sin(angle);
        let gradient = ctx.createRadialGradient(px, py, 0, px, py, 3);
        gradient.addColorStop(0, `hsla(${(time*5 + i*6)%360},100%,85%,1)`);
        gradient.addColorStop(1, 'rgba(255,215,0,0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(px, py, 1.8 + Math.sin(time*0.03+i)*0.5, 0, Math.PI*2);
        ctx.fill();
    }
}
// Аурная оболочка вокруг всей мандалы
function drawAura(intensity){
    const auraParticles = 120;
    for(let i=0; i<auraParticles; i++){
        let angle = (i/auraParticles)*Math.PI*2 + Math.random()*0.2;
        let radius = baseRadius*fractalLevels + 50 + Math.sin(time*0.01+i)*15;
        let px = radius*Math.cos(angle);
        let py = radius*Math.sin(angle);
        let gradient = ctx.createRadialGradient(px, py, 0, px, py, 6);
        gradient.addColorStop(0, `hsla(${(time*3 + i*4)%360},100%,60%,${0.3 + intensity*0.5})`);
        gradient.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(px, py, 2 + Math.random()*1.5, 0, Math.PI*2);
        ctx.fill();
    }
}
// Основная функция отрисовки
function draw() {
    ctx.clearRect(0,0,w,h);
    ctx.save();
    ctx.translate(w/2,h/2);
    analyser.getByteFrequencyData(dataArray);
    let intensity = Math.max(...dataArray)/256;
    intensity = Math.pow(intensity, 1.5);
    // BPM-подобная пульсация
    let currentPeak = dataArray.slice(0, 20).reduce((a,b)=>a+b,0);
    if(currentPeak - lastPeak > 50){
        bpmIntensity = 0.3 + Math.random()*0.3;
    } else {
        bpmIntensity *= 0.92;
    }
    lastPeak = currentPeak;
    // Пульсация центра и рандомизация
    let pulse = Math.sin(time*0.02 + Math.random()*0.1) * 0.1 + 1;
    let vib = (mouseHover?0.05:0) + (mouseClick?0.15:0) + intensity*0.3 + bpmIntensity;
    // Центральный вихрь
    drawCentralVortex(vib);
    // Аура
    drawAura(vib);
    for(let layer=1; layer<=fractalLevels; layer++){
        let r = baseRadius*layer*pulse*(0.85 + Math.random()*0.3);
        for(let i=0;i<petals;i++){
            let angle = i*(Math.PI*2/petals) + rotationSpeed*time + (Math.random()-0.5)*vib;
            let zVib = Math.sin(time*0.02 + layer)*2; // Z-вибрация для всей мандалы
            let x = (r + zVib)*Math.cos(angle);
            let y = (r + zVib)*Math.sin(angle);
            let hue = (time*2 + i*45 + Math.random()*30)%360;
            drawFractalLine(x, y, basePetalRadius, fractalLevels, hue, vib);
        }
    }
    ctx.restore();
    time++;
    requestAnimationFrame(draw);
}
// Запуск аудио-контекста после клика
document.body.addEventListener('click', ()=> {
    if(audioCtx.state === 'suspended') audioCtx.resume();
});
draw();
</script>
</body>
</html>
