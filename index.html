<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>COSMIC TRANCE – Digital Ocean Sun</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      color: #fff;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
                   Roboto, sans-serif;
    }
    canvas {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      background: radial-gradient(circle at center, #050505 0%, #000 55%, #000 100%);
    }
    .ui-main {
      position: fixed;
      left: 7vw;
      bottom: 8vh;
      z-index: 2;
      pointer-events: none;
      mix-blend-mode: screen;
      text-transform: uppercase;
      letter-spacing: 0.25em;
    }
    .ui-main h1 {
      font-size: clamp(1.6rem, 3vw, 3.2rem);
      font-weight: 600;
      margin-bottom: 0.7rem;
      text-shadow: 0 0 16px rgba(255, 255, 255, 0.8);
    }
    .ui-main .divider {
      width: 110px;
      height: 1px;
      background: linear-gradient(
        90deg,
        rgba(255, 255, 255, 0) 0%,
        rgba(255, 255, 255, 0.9) 50%,
        rgba(255, 255, 255, 0) 100%
      );
      margin: 0.6rem 0 0.7rem -4px;
    }
    .ui-main p {
      font-size: 0.7rem;
      opacity: 0.8;
    }
    .ui-main .tagline {
      font-size: 0.65rem;
      margin-top: 0.35rem;
      opacity: 0.7;
    }
    .corner-label {
      position: fixed;
      right: 4vw;
      top: 4vh;
      z-index: 2;
      font-size: 0.6rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      opacity: 0.55;
      pointer-events: none;
      mix-blend-mode: screen;
    }
    .corner-label span {
      display: block;
      text-align: right;
    }
    .corner-label span:first-child {
      margin-bottom: 0.2rem;
    }
  </style>
</head>
<body>
  <canvas id="scene"></canvas>

  <div class="ui-main">
    <h1>COSMIC TRANCE</h1>
    <div class="divider"></div>
    <p>Digital ocean • Mandala sun • Quantum geometry</p>
    <p class="tagline">Blue sound waves • Interference reflection</p>
  </div>

  <div class="corner-label">
    <span>SHADER SYSTEM v5.1</span>
    <span>WEBGL / OCEAN–SUN–TORUS GALAXY</span>
  </div>

  <script>
    const canvas = document.getElementById("scene");
    const gl = canvas.getContext("webgl", { antialias: true, premultipliedAlpha: false });

    if (!gl) {
      alert("WebGL не поддерживается этим браузером.");
    }

    function resize() {
      const w = window.innerWidth;
      const h = window.innerHeight;
      canvas.width = w;
      canvas.height = h;
      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    }
    window.addEventListener("resize", resize);
    resize();

    let mouse = { x: 0.5, y: 0.5 };
    let glitchStrength = 0.0;

    window.addEventListener("pointermove", (e) => {
      mouse.x = e.clientX / window.innerWidth;
      mouse.y = 1.0 - e.clientY / window.innerHeight;
    });

    window.addEventListener("click", () => {
      glitchStrength = 1.0;
    });

    const vsSource = `
      attribute vec2 a_position;
      varying vec2 v_uv;
      void main() {
        v_uv = a_position * 0.5 + 0.5;
        gl_Position = vec4(a_position, 0.0, 1.0);
      }
    `;

    const fsSource = `
      precision highp float;

      uniform vec2 u_resolution;
      uniform float u_time;
      uniform vec2 u_mouse;
      uniform float u_glitch;

      varying vec2 v_uv;

      // ===== Море: градиент снизу до горизонта =====
      const vec3 WATER_BOTTOM_COLOR  = vec3(0.012, 0.055, 0.16);
      const vec3 WATER_HORIZON_COLOR = vec3(0.003, 0.020, 0.070);

      // ===== Солнце – 5 колец =====
      const float R1_RADIUS = 0.12;
      const float R2_RADIUS = 0.18;
      const float R3_RADIUS = 0.24;
      const float R4_RADIUS = 0.28;
      const float R5_RADIUS = 0.32;

      const float R1_FREQ = 10.0;
      const float R2_FREQ = 13.0;
      const float R3_FREQ = 16.0;
      const float R4_FREQ = 20.0;
      const float R5_FREQ = 26.0;

      const float R1_AMP = 0.018;
      const float R2_AMP = 0.020;
      const float R3_AMP = 0.023;
      const float R4_AMP = 0.026;
      const float R5_AMP = 0.030;

      const float R1_SPEED = 1.1;
      const float R2_SPEED = 1.3;
      const float R3_SPEED = 1.6;
      const float R4_SPEED = 1.9;
      const float R5_SPEED = 2.3;

      const float R1_WIDTH = 0.0060;
      const float R2_WIDTH = 0.0048;
      const float R3_WIDTH = 0.0040;
      const float R4_WIDTH = 0.0032;
      const float R5_WIDTH = 0.0025;

      const float R1_INTENS = 1.2;
      const float R2_INTENS = 1.1;
      const float R3_INTENS = 1.0;
      const float R4_INTENS = 0.9;
      const float R5_INTENS = 0.8;

      const vec3 RING_COLOR_INNER = vec3(1.25, 0.40, 0.16);
      const vec3 RING_COLOR_OUTER = vec3(0.90, 0.12, 0.05);

      // ===== 5 толстых волн =====
      const float W1_POS = 0.12;
      const float W2_POS = 0.22;
      const float W3_POS = 0.34;
      const float W4_POS = 0.50;
      const float W5_POS = 0.70;

      const float W1_AMP = 0.035;
      const float W2_AMP = 0.032;
      const float W3_AMP = 0.030;
      const float W4_AMP = 0.027;
      const float W5_AMP = 0.024;

      const float W1_SPEED = 1.2;
      const float W2_SPEED = 1.0;
      const float W3_SPEED = 0.9;
      const float W4_SPEED = 0.8;
      const float W5_SPEED = 0.7;

      const float W1_FREQ1 = 24.0;
      const float W2_FREQ1 = 22.0;
      const float W3_FREQ1 = 20.0;
      const float W4_FREQ1 = 18.0;
      const float W5_FREQ1 = 16.0;

      const float W1_FREQ2 = 11.0;
      const float W2_FREQ2 = 10.0;
      const float W3_FREQ2 =  9.0;
      const float W4_FREQ2 =  8.0;
      const float W5_FREQ2 =  7.0;

      const float W1_WIDTH = 0.0065;
      const float W2_WIDTH = 0.0050;
      const float W3_WIDTH = 0.0040;
      const float W4_WIDTH = 0.0032;
      const float W5_WIDTH = 0.0025;

      const float W1_ALPHA = 1.0;
      const float W2_ALPHA = 0.9;
      const float W3_ALPHA = 0.75;
      const float W4_ALPHA = 0.6;
      const float W5_ALPHA = 0.5;

      const float W1_BLEND = 0.0;
      const float W2_BLEND = 0.25;
      const float W3_BLEND = 0.45;
      const float W4_BLEND = 0.65;
      const float W5_BLEND = 0.85;

      const vec3 WAVE_COLOR_NEAR_WHITE = vec3(1.0, 1.0, 1.0);
      const vec3 WAVE_COLOR_BLUE       = vec3(0.55, 0.80, 1.10);

      // ================= ВСПОМОГАТЕЛЬНЫЕ =================

      float hash(vec2 p) {
        return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
      }

      float lineAround(float d, float w) {
        return 1.0 - smoothstep(w, w * 4.0, abs(d));
      }

      float waveRing(vec2 p, float radius, float freq, float amp, float speed, float width) {
        float ang = atan(p.y, p.x);
        float rad = length(p);

        float wave =
          sin(ang * freq + u_time * speed) +
          0.5 * sin(ang * (freq * 1.9) - u_time * (speed * 1.3));

        float target = radius + wave * amp;
        float d = rad - target;
        return lineAround(d, width);
      }

      void main() {
        vec2 res = u_resolution;
        vec2 uv = gl_FragCoord.xy / res;
        float g = u_glitch;

        float horizon = 0.45;
        float horizonY = horizon;
        float centerXNorm = 2.0 / 3.0;
        float sunScale = 0.7;
        float aspect = res.x / res.y;

        // цикл солнца (восход → зенит → закат → ночь)
        float sunPhase = u_time * 0.05;
        float sunOffset = -cos(sunPhase) * 0.30;
        float sunCenterY = horizonY + sunOffset;

        float maxRadius = R5_RADIUS * sunScale;
        float hidden = clamp((horizonY - sunCenterY) / maxRadius, 0.0, 1.0);
        float visibility = 1.0 - hidden;

        // коэффициенты "заката" и "ночи"
        float duskFactor  = smoothstep(0.25, 0.65, hidden);
        float nightFactor = smoothstep(0.60, 0.95, hidden);

        vec3 col;

        // ===== ДИНАМИЧЕСКОЕ НЕБО =====
        if (uv.y > horizon) {
          float t = (uv.y - horizon) / (1.0 - horizon);
          t = clamp(t, 0.0, 1.0);

          // Чистое насыщенно-голубое небо (день) с лёгким уходом в циан/зелёный
          vec3 daySkyBot  = vec3(0.02, 0.32, 0.82);
          vec3 daySkyTop  = vec3(0.06, 0.50, 1.05);
          vec3 daySky     = mix(daySkyBot, daySkyTop, t);

          // Тёмно-синий закат
          vec3 duskSkyBot = vec3(0.01, 0.02, 0.09);
          vec3 duskSkyTop = vec3(0.02, 0.06, 0.18);
          vec3 duskSky    = mix(duskSkyBot, duskSkyTop, t);

          // Почти чёрная ночь
          vec3 nightSkyBot = vec3(0.0, 0.0, 0.01);
          vec3 nightSkyTop = vec3(0.0, 0.0, 0.018);
          vec3 nightSky    = mix(nightSkyBot, nightSkyTop, t);

          vec3 skyDayDusk = mix(daySky, duskSky, duskFactor);
          vec3 sky        = mix(skyDayDusk, nightSky, nightFactor);

          col = sky;

          // ===== ГАЛАКТИКА-ТОР (приближённая, крупные звёзды, кучность) ТОЛЬКО НОЧЬЮ =====
          if (nightFactor > 0.0) {
            // координаты в небе [-1,1]
            vec2 suv = uv * 2.0 - 1.0;

            // сдвиг центра чуть вправо/вниз (ближе к горизонту)
            suv.x -= 0.05;
            suv.y -= 0.05;

            // немного сплющить по вертикали
            suv.y *= 0.60;

            // наклон "тора" градусов на 35
            float tilt = radians(35.0);
            float ct = cos(tilt);
            float st = sin(tilt);
            mat2 tiltRot = mat2(ct, -st, st, ct);
            vec2 gpos = tiltRot * suv;

            // правый край чуть ниже (уходит под горизонт)
            gpos.y -= gpos.x * 0.20;

            // параметры "тора" (больше и ближе)
            float R = 0.80;  // большой радиус
            float r = 0.22;  // толщина

            float lenp = length(gpos);
            float ringDist = abs(lenp - R);   // 0 на кольце
            float band = exp(- (ringDist * ringDist) / (r * r));  // мягкий тор

            // один рукав
            float ang = atan(gpos.y, gpos.x);
            float sector = smoothstep(-0.25, 1.10, ang);
            band *= sector;

            // убираем центр – "чёрная дыра"
            float coreHole = smoothstep(0.10, 0.20, lenp);
            band *= coreHole;

            // плотность падает к краям
            float radialFalloff = exp(-lenp * 1.2);
            float density = band * radialFalloff;

            // кластеризация: отдельный шум с низкой частотой
            vec2 clusterCell = floor(gpos * 4.0);
            float clusterNoise = hash(clusterCell + 19.37);
            float clusterWeight = smoothstep(0.40, 1.0, clusterNoise);
            density *= clusterWeight;

            // дискретные "ячейки" для звёзд
            vec2 starUV   = gpos * 2.4;
            vec2 starCell = floor(starUV * res.y * 0.20);
            vec2 cellFrac = fract(starUV * res.y * 0.20) - 0.5;

            float baseStarNoise = hash(starCell + 37.91);
            float extraNoise    = hash(starCell + 88.19);

            // вероятность звезды зависит от плотности тора
            float prob = clamp(pow(density, 0.85) * 2.8, 0.0, 1.0);
            // немного случайности: где-то пусто, где-то густо
            prob *= smoothstep(0.25, 1.0, extraNoise);

            float starPresence = step(1.0 - prob, baseStarNoise);

            // "глубина": ближняя часть тора (справа, ниже) — крупнее
            float depthSide = smoothstep(-0.20, 0.85, gpos.x);
            float depthVert = 1.0 - smoothstep(0.25, 0.80, gpos.y + 0.25);
            float depth = clamp(0.25 + 0.75 * depthSide * depthVert, 0.0, 1.0);

            // диаметр ощущается 10–20 px за счёт большого starSize
            float starSize = mix(1.0, 5.0, depth);
            float starShape = exp(-dot(cellFrac, cellFrac) / (0.008 * starSize));
            float star = starPresence * starShape;

            // мерцание
            float starTwinkle = 0.7 + 0.3 * sin(u_time * 2.7 + baseStarNoise * 60.0);
            star *= starTwinkle;

            // цвет: холодные сине-белые, чуть теплее на ближней части
            vec3 coldCol = vec3(0.80, 0.90, 1.35);
            vec3 warmCol = vec3(1.10, 1.20, 1.85);
            vec3 starCol = mix(coldCol, warmCol, depth);

            vec3 galaxy = starCol * star;

            float galaxyStrength = nightFactor * 1.35;
            col += galaxy * galaxyStrength;

            // редкий фоновый "микро-стат" по всему небу
            vec2 bgCell = floor((uv * res) * 0.35);
            float bgN   = hash(bgCell + 123.4);
            float bgStar = step(0.996, bgN) * smoothstep(0.0, 0.25, bgN);
            vec3 bgCol = vec3(0.65, 0.75, 1.25);
            col += bgCol * bgStar * nightFactor * 0.4;
          }
        } else {
          // ===== МОРЕ =====
          float t = uv.y / horizon;
          t = clamp(t, 0.0, 1.0);
          vec3 water = mix(WATER_BOTTOM_COLOR, WATER_HORIZON_COLOR, t);

          // чуть ярче в средней полосе
          float midBand = 1.0 - smoothstep(0.45, 1.0, t);
          float brighten = 1.0 + 0.22 * midBand;
          water *= brighten;

          // днём море светлее, ночью темнее
          float waterDayNight = mix(1.35, 0.55, hidden);
          water *= waterDayNight;

          // дополнительное сильное осветление горизонта при восходе/дне
          float nearH = exp(-pow((t - 1.0) / 0.16, 2.0)); // полоса у горизонта
          float sunUp = 1.0 - hidden;                    // чем выше солнце, тем светлее
          vec3 horizonGlow = vec3(0.40, 0.70, 1.20);     // холодный голубой глянец
          water += horizonGlow * nearH * sunUp * 0.55;

          col = water;
        }

        // ===== СОЛНЦЕ (мандала) =====
        vec2 p = vec2((uv.x - centerXNorm) * aspect, uv.y - sunCenterY);
        float dSun = length(p);
        float angle = atan(p.y, p.x);
        float aboveHorizon = step(horizon, uv.y);

        vec3 ringsColor = vec3(0.0);

        float t1 = 0.00;
        float t2 = 0.25;
        float t3 = 0.50;
        float t4 = 0.75;
        float t5 = 1.00;

        // R1
        {
          float r = R1_RADIUS * sunScale;
          float f = R1_FREQ;
          float a = R1_AMP * sunScale;
          float s = R1_SPEED;
          float w = R1_WIDTH;
          float mask = waveRing(p, r, f, a, s, w) * R1_INTENS;
          vec3 c = mix(RING_COLOR_INNER, RING_COLOR_OUTER, t1);
          ringsColor += c * mask;
        }
        // R2
        {
          float r = R2_RADIUS * sunScale;
          float f = R2_FREQ;
          float a = R2_AMP * sunScale;
          float s = R2_SPEED;
          float w = R2_WIDTH;
          float mask = waveRing(p, r, f, a, s, w) * R2_INTENS;
          vec3 c = mix(RING_COLOR_INNER, RING_COLOR_OUTER, t2);
          ringsColor += c * mask;
        }
        // R3
        {
          float r = R3_RADIUS * sunScale;
          float f = R3_FREQ;
          float a = R3_AMP * sunScale;
          float s = R3_SPEED;
          float w = R3_WIDTH;
          float mask = waveRing(p, r, f, a, s, w) * R3_INTENS;
          vec3 c = mix(RING_COLOR_INNER, RING_COLOR_OUTER, t3);
          ringsColor += c * mask;
        }
        // R4
        {
          float r = R4_RADIUS * sunScale;
          float f = R4_FREQ;
          float a = R4_AMP * sunScale;
          float s = R4_SPEED;
          float w = R4_WIDTH;
          float mask = waveRing(p, r, f, a, s, w) * R4_INTENS;
          vec3 c = mix(RING_COLOR_INNER, RING_COLOR_OUTER, t4);
          ringsColor += c * mask;
        }
        // R5
        {
          float r = R5_RADIUS * sunScale;
          float f = R5_FREQ;
          float a = R5_AMP * sunScale;
          float s = R5_SPEED;
          float w = R5_WIDTH;
          float mask = waveRing(p, r, f, a, s, w) * R5_INTENS;
          vec3 c = mix(RING_COLOR_INNER, RING_COLOR_OUTER, t5);
          ringsColor += c * mask;
        }

        float coreBase = 0.12 * sunScale;
        float coreMask = 1.0 - smoothstep(coreBase, coreBase + 0.005, dSun);
        float rNorm = dSun / coreBase;

        float radialBeat = 0.5 + 0.5 * sin(rNorm * 40.0 - u_time * 6.0);
        float harmonic   = 0.5 + 0.5 * sin(rNorm * 80.0 - u_time * 12.0);
        float angularMod = 0.5 + 0.5 * sin(angle * 8.0 + u_time * 1.5);

        float soundPattern = radialBeat * 0.55 + harmonic * 0.25 + angularMod * 0.35;
        soundPattern = clamp(soundPattern, 0.0, 1.0);

        vec3 coreBaseCol = vec3(0.80, 0.08, 0.03);
        vec3 coreHotCol  = vec3(1.35, 0.45, 0.12);
        vec3 sunColorCore = mix(coreBaseCol, coreHotCol, pow(soundPattern, 1.2));

        col += aboveHorizon * ringsColor;
        col += aboveHorizon * sunColorCore * coreMask * 1.7;

        float haloH = coreBase * 1.8;
        float haloT = smoothstep(0.0, haloH, abs(uv.y - horizonY));
        float halo = 1.0 - haloT;
        vec3 haloColor = vec3(0.90, 0.23, 0.13);
        float haloIntensity = mix(0.14, 0.42, hidden);
        col += step(horizon, uv.y) * (haloColor * halo * haloIntensity);

        // ===== ОКЕАН: волны + глич =====
        if (uv.y < horizon) {
          vec2 uvOcean = uv;

          if (g > 0.0) {
            float band = floor(uvOcean.y * res.y / 10.0);
            float n = hash(vec2(band, floor(u_time * 40.0)));
            float shift = (n - 0.5) * 0.03 * g;
            uvOcean.x += shift;
          }

          float wavesFine = 0.0;

          for (int i = 0; i < 24; i++) {
            float fi = float(i);
            float tLayer = fi / 23.0;
            float yBase = horizon * (0.08 + tLayer * 0.9);

            float amp = 0.01 + tLayer * 0.02;
            float speed = 0.4 + tLayer * 0.9;
            float k1 = 15.0 + tLayer * 10.0;
            float k2 = 5.0 + tLayer * 6.0;

            float phase = u_time * speed + uvOcean.x * k1 + fi * 0.5;
            float phase2 = u_time * (speed * 0.7) - uvOcean.x * k2;

            float offset =
              sin(phase) * amp * (0.4 + 0.6 * sin(u_time * 0.7 + fi)) +
              sin(phase2) * amp * 0.5;

            float yTarget = yBase + offset;
            float line = lineAround(uv.y - yTarget, 0.0015);

            float alpha = 0.4 * (1.0 - tLayer);
            wavesFine += line * alpha;
          }

          // W1 — нижняя, глухо белая
          {
            float yBase = horizon * W1_POS;
            float amp   = W1_AMP;
            float speed = W1_SPEED;
            float k1    = W1_FREQ1;
            float k2    = W1_FREQ2;

            float phase  = u_time * speed + uvOcean.x * k1;
            float phase2 = u_time * (speed * 0.6) - uvOcean.x * k2;

            float offset =
              sin(phase) * amp +
              sin(phase2) * amp * 0.5;

            float yTarget = yBase + offset;
            float line = lineAround(uv.y - yTarget, W1_WIDTH);

            float w1Mask = clamp(line * 1.6, 0.0, 1.0);

            // чистая непрозрачная белая полоса
            col = mix(col, vec3(1.0, 1.0, 1.0), w1Mask);

            // лёгкий голубой глоу по краям
            vec3 waveColGlow = mix(WAVE_COLOR_NEAR_WHITE, WAVE_COLOR_BLUE, W1_BLEND);
            col += waveColGlow * line * 0.35;
          }

          // W2
          {
            float yBase = horizon * W2_POS;
            float amp   = W2_AMP;
            float speed = W2_SPEED;
            float k1    = W2_FREQ1;
            float k2    = W2_FREQ2;

            float phase  = u_time * speed + uvOcean.x * k1;
            float phase2 = u_time * (speed * 0.6) - uvOcean.x * k2;

            float offset =
              sin(phase) * amp +
              sin(phase2) * amp * 0.5;

            float yTarget = yBase + offset;
            float line = lineAround(uv.y - yTarget, W2_WIDTH);
            vec3 waveCol = mix(WAVE_COLOR_NEAR_WHITE, WAVE_COLOR_BLUE, W2_BLEND);
            col += waveCol * line * W2_ALPHA;
          }

          // W3
          {
            float yBase = horizon * W3_POS;
            float amp   = W3_AMP;
            float speed = W3_SPEED;
            float k1    = W3_FREQ1;
            float k2    = W3_FREQ2;

            float phase  = u_time * speed + uvOcean.x * k1;
            float phase2 = u_time * (speed * 0.6) - uvOcean.x * k2;

            float offset =
              sin(phase) * amp +
              sin(phase2) * amp * 0.5;

            float yTarget = yBase + offset;
            float line = lineAround(uv.y - yTarget, W3_WIDTH);
            vec3 waveCol = mix(WAVE_COLOR_NEAR_WHITE, WAVE_COLOR_BLUE, W3_BLEND);
            col += waveCol * line * W3_ALPHA;
          }

          // W4
          {
            float yBase = horizon * W4_POS;
            float amp   = W4_AMP;
            float speed = W4_SPEED;
            float k1    = W4_FREQ1;
            float k2    = W4_FREQ2;

            float phase  = u_time * speed + uvOcean.x * k1;
            float phase2 = u_time * (speed * 0.6) - uvOcean.x * k2;

            float offset =
              sin(phase) * amp +
              sin(phase2) * amp * 0.5;

            float yTarget = yBase + offset;
            float line = lineAround(uv.y - yTarget, W4_WIDTH);
            vec3 waveCol = mix(WAVE_COLOR_NEAR_WHITE, WAVE_COLOR_BLUE, W4_BLEND);
            col += waveCol * line * W4_ALPHA;
          }

          // W5
          {
            float yBase = horizon * W5_POS;
            float amp   = W5_AMP;
            float speed = W5_SPEED;
            float k1    = W5_FREQ1;
            float k2    = W5_FREQ2;

            float phase  = u_time * speed + uvOcean.x * k1;
            float phase2 = u_time * (speed * 0.6) - uvOcean.x * k2;

            float offset =
              sin(phase) * amp +
              sin(phase2) * amp * 0.5;

            float yTarget = yBase + offset;
            float line = lineAround(uv.y - yTarget, W5_WIDTH);
            vec3 waveCol = mix(WAVE_COLOR_NEAR_WHITE, WAVE_COLOR_BLUE, W5_BLEND);
            col += waveCol * line * W5_ALPHA;
          }

          vec3 waveColorBase = vec3(0.30, 0.60, 1.00);
          col += waveColorBase * wavesFine * 0.7;

          // отражение солнца
          float tRef = (horizon - uv.y) / horizon;
          tRef = clamp(tRef, 0.0, 1.0);

          float widthRef = 0.10;
          float dx = (uvOcean.x - centerXNorm) / widthRef;
          float spot = exp(-dx * dx * 2.0) * (1.0 - tRef);

          float stripePhase = fract(uv.y * 80.0 - u_time * 1.2);
          float stripe =
            smoothstep(0.0, 0.12, stripePhase) *
            (1.0 - smoothstep(0.70, 1.0, stripePhase));

          float inter =
            0.5 + 0.5 * sin(uvOcean.x * 220.0 + uv.y * 40.0 + u_time * 4.0);

          float reflection = spot * stripe * inter;
          reflection *= pow(visibility, 1.2);

          vec3 reflColor = vec3(1.0, 0.32, 0.18);
          col += reflColor * reflection * 1.5;
        }

        // виньетка
        vec2 centered = (gl_FragCoord.xy - 0.5 * res) / res.y;
        float rr = length(centered);
        float vignette = smoothstep(1.4, 0.4, rr);
        col *= vignette;

        // filmic
        col = 1.0 - exp(-col);
        col = clamp(col, 0.0, 1.0);

        gl_FragColor = vec4(col, 1.0);
      }
    `;

    function createShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    function createProgram(gl, vsSource, fsSource) {
      const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
      const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
      const program = gl.createProgram();
      gl.attachShader(program, vs);
      gl.attachShader(program, fs);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
        return null;
      }
      return program;
    }

    const program = createProgram(gl, vsSource, fsSource);
    gl.useProgram(program);

    const positionLocation = gl.getAttribLocation(program, "a_position");
    const timeLocation = gl.getUniformLocation(program, "u_time");
    const resolutionLocation = gl.getUniformLocation(program, "u_resolution");
    const mouseLocation = gl.getUniformLocation(program, "u_mouse");
    const glitchLocation = gl.getUniformLocation(program, "u_glitch");

    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    const quad = new Float32Array([
      -1, -1,
       1, -1,
      -1,  1,
      -1,  1,
       1, -1,
       1,  1,
    ]);
    gl.bufferData(gl.ARRAY_BUFFER, quad, gl.STATIC_DRAW);

    gl.enableVertexAttribArray(positionLocation);
    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

    let startTime = performance.now();
    let lastTime = startTime;

    function render(now) {
      const t = (now - startTime) * 0.001;
      const dt = (now - lastTime) * 0.001;
      lastTime = now;

      if (glitchStrength > 0) {
        glitchStrength -= dt * 2.2;
        if (glitchStrength < 0) glitchStrength = 0;
      }

      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
      gl.clearColor(0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT);

      gl.useProgram(program);
      gl.uniform1f(timeLocation, t);
      gl.uniform2f(resolutionLocation, gl.drawingBufferWidth, gl.drawingBufferHeight);
      gl.uniform2f(mouseLocation, mouse.x, mouse.y);
      gl.uniform1f(glitchLocation, glitchStrength);

      gl.drawArrays(gl.TRIANGLES, 0, 6);

      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);
  </script>
</body>
</html>
